# DevTools Project
[![Java CI with Checkstyle and Coverage](https://github.com/EchoesOfTime/java-dev-tools/actions/workflows/ci.yml/badge.svg)](https://github.com/EchoesOfTime/java-dev-tools/actions/workflows/ci.yml)


## Quick Start
Через Gradle Tool Window (IDEA):

1. Открыть View → Tool Windows → Gradle.
2. В дереве задач выбери:
   * `Tasks → application → run`
   * `Tasks → build → build`
   * `Tasks → verification → test`
     (все задачи запускай двойным кликом)
3. Альтернативно используй Ctrl + Ctrl (Run Anything)
```bash
gradle run
gradle build
gradle test
```
IDEA выполнит команду без терминала.

## Packages
`ru.mentee.power` — основной пакет с классами

## Таблица переменных/полей MenteeProgress

- `menteeName` – имя студента
- `sprintNumber` – номер спринта
- `plannedHoursPerWeek` - запланированные часы
- `readyForSprint()` - метод без аргументов, который возвращает логическое значение (true или false).

MenteeProgress - String menteeName, int sprintNumber, int plannedHoursPerWeek

Ссылка на урок
- https://mentee-power.xl.ru/learn/eZTCGC3TuEW8P6jDvNRFZw/theory

## Правило веток: feature/DVT-X
В проекте используется стратегия ветвления, основанная на ветках `feature`.
*   `master` — основная ветка для стабильного кода.
*   `feature/DVT-X` — ветка для разработки задачи с идентификатором DVT-3.


## Git локальный цикл: шаги и команды

1.  Внести изменения в код.
2.  `git add <файлы>` — добавить изменения в индекс.
3.  `git commit -m "сообщение"` — зафиксировать изменения.
4.  `git push` — отправить в удалённый репозиторий.


## Информационный поиск — результаты DVT-11

### Запросы и источники

| № | Запрос                        | Операторы                                                         | Официальный источник                                                                                                   | Альтернатива                                                                                                          | Статус | Дата проверки |
|---|-------------------------------|-------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|--------|---------------|
| 1 | Lombok Gradle Short           | site:search.maven.org "lombok" OR site:mvnrepository.com "lombok" | https://search.maven.org/artifact/org.projectlombok/lombok/1.18.30/jar                                                 | https://mvnrepository.com/artifact/org.projectlombok/lombok/1.18.30                                                   | 200 OK | 29.12.2025    |
| 2 | Java Stream API               | site:docs.oracle.com "stream api" intitle:api java 25             | https://docs.oracle.com/en/database/other-databases/nosql-database/25.3/java-api/oracle/kv/pubsub/package-summary.html | https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.2206/develop-applications/using-repository-api.html | 200 OK | 30.12.2025    |
| 3 | горячие клавиши IntelliJ IDEA | site:www.jetbrains.com/help "keymap" "intellij idea"              | https://www.jetbrains.com/help/idea/mastering-keyboard-shortcuts.html                                                  | https://wp-kama.ru/note/php-storm-hotkeys                                                                             | 200 OK | 30.12.2025    |

### AI-промпты и сравнение ассистентов

#### Промпт 1: План решения

**Задача:** Нужно подключить плагин Checkstyle

**Контекст:** Проект собран на Java 25, Gradle

**Ограничения:** Без использования регулярных выражений на данном этапе, простая проверка наличия @ и точки

**Ожидаемый результат:** план из 3-5 шагов, объяснение "почему именно так", НЕ пиши код — я реализую сам

**Критерии успеха:** Плагин Checkstyle подключен, задачи checkstyleMain, checkstyleTest отображается в verification, Gradle

**AI-1 (ChatGPT):**

Окей, давай аккуратный план без кода, как ты и просил. Ниже — 4 шага, каждый с пояснением почему именно так и как это ведёт к критериям успеха.

Шаг 1. Подключить Checkstyle как Gradle-плагин

Что делаем:
Подключаешь стандартный Gradle-плагин Checkstyle и фиксируешь версию Checkstyle (не полагаться на дефолт).

Почему так:

Gradle сам создаёт задачи checkstyleMain и checkstyleTest, но только если плагин подключён правильно.

Фиксация версии важна для Java 25: так ты избежишь сюрпризов с несовместимостью и различиями правил между версиями.

Это минимальное и «каноничное» подключение — без кастомных тасков и магии.

➡️ После этого Gradle уже знает, что такое Checkstyle, но ещё не знает, что именно проверять.

Шаг 2. Завести отдельный конфигурационный файл Checkstyle

Что делаем:
Создаёшь checkstyle.xml (или аналогичное имя) в стандартном месте проекта и указываешь Gradle, что он должен использовать именно этот файл.

Почему так:

Checkstyle всегда работает от конфигурации, без неё задачи формально есть, но фактически бесполезны.

Отдельный файл даёт прозрачность: правила не размазаны по Gradle, их легко читать и менять.

Это позволит тебе сейчас сделать очень простую проверку (наличие @ и .), а позже — безболезненно усложнить логику.

➡️ На этом этапе Checkstyle уже запускается, но может ничего не находить — и это нормально.

Шаг 3. Добавить простое правило без регулярных выражений

Что делаем:
В конфигурации Checkstyle выбираешь максимально простой механизм проверки текста файлов, который работает на уровне символов, а не regex, и настраиваешь его на проверку наличия @ и точки.

Почему так:

Ты соблюдаешь ограничение «без регулярных выражений».

Проверка символов — самый надёжный старт: меньше ложных срабатываний, легче отлаживать.

Такой подход хорошо ложится в философию Checkstyle: сначала простые синтаксические гарантии, потом — более умные правила.

➡️ Здесь появляется реальная проверка, а не просто подключённый плагин.

Шаг 4. Проверить интеграцию с lifecycle verification

Что делаем:
Запускаешь стандартные Gradle-таски (check / verification) и смотришь, что:

checkstyleMain

checkstyleTest
появляются в группе verification и реально выполняются.

Почему так:

Это главный критерий «плагин подключён правильно», а не просто «Gradle не упал».

Если задачи входят в check, значит Checkstyle стал частью CI-пайплайна автоматически.

Ты сразу видишь, как проект будет вести себя на сборке, а не только локально.

➡️ Это финальная валидация, что всё встроено корректно.

Итог

После этих шагов:

Checkstyle подключён ✔

checkstyleMain и checkstyleTest видны в verification ✔

Проверка простая, без regex, и готова к развитию ✔

Если хочешь, следующим шагом можем обсудить как эволюционно усложнять правило, не ломая текущую конфигурацию.

**AI-2 (DeepSeek):**

Отличная задача! Вот пошаговый план, который учитывает ваш контекст и ограничения.

План из 5 шагов
Шаг 1: Добавить плагин Checkstyle в build.gradle
Действие: В блок plugins добавь строку id 'checkstyle'.
Почему: Плагинный DSL — современный и лаконичный способ подключения. Он автоматически настраивает нужные конфигурации и создает стандартные задачи (checkstyleMain, checkstyleTest), которые интегрируются в группу verification. Это основа для всего последующего.

Шаг 2: (Опционально, но рекомендуется) Настроить версию Checkstyle
Действие: В блок checkstyle добавь конфигурацию toolVersion.
Почему: Последняя версия Checkstyle лучше совместима с новыми синтаксическими конструкциями Java (ваша версия Java 25 — это фактически Java 21 LTS или новее на момент ответа). Фиксация версии обеспечивает воспроизводимость сборки на разных машинах.

Шаг 3: Настроить базовую конфигурацию (конфиг или правило)
Действие: Создай файл config/checkstyle/checkstyle.xml или прямо в build.gradle задай простое правило для проверки формата email.
Почему: Checkstyle требует набора правил для проверки. Так как нужна простая проверка (наличие "@" и точки), это можно сделать через встроенную проверку RegexpSinglelineJava (несмотря на её название, мы будем использовать её БЕЗ регулярных выражений, с простым текстом) или создать кастомную проверку. На данном этапе проще начать с базового XML-конфига, даже если он будет содержать только наши кастомные правила.

Шаг 4: Настроить объект checkstyle в build.gradle
Действие: В блок checkstyle укажи путь к созданному конфигурационному файлу через configFile = file(...).
Почему: Нужно явно указать Gradle, какой файл конфигурации использовать. Если этого не сделать, плагин попытается найти дефолтный (sun_checks.xml), который не содержит наших специфичных правил.

Шаг 5: Запустить задачи и проверить интеграцию
Действие: Выполни ./gradlew tasks --group verification или ./gradlew check.
Почему:

Первая команда покажет, что задачи checkstyleMain и checkstyleTest созданы и находятся в нужной группе verification.

Вторая команда (check) запустит все задачи верификации, включая Checkstyle. Это подтвердит, что плагин не только подключен, но и интегрирован в стандартный жизненный цикл сборки (задача check зависит от checkstyleMain и checkstyleTest).

Ключевые моменты реализации проверки (без кода, как концепция):
Для простой проверки наличия "@" и точки в строке (например, в комментариях) в конфигурационном XML можно использовать модуль RegexpSinglelineJava, но передать в параметр format простую строку "@" (а потом "."). Checkstyle будет интерпретировать это не как регулярное выражение, а как буквальный текст для поиска. Это обходной путь в рамках ограничения "без regex".

Более чистый путь — написать простую кастомную проверку (Custom Check), но это выходит за рамки "простого плана подключения".

Критерии успеха, которые ты увидишь после реализации:

В выводе ./gradlew tasks будут задачи checkstyleMain и checkstyleTest в группе Verification tasks.

Команда ./gradlew checkstyleMain выполнится без ошибок конфигурации.

При наличии в коде строки без "@" или без точки (в зависимости от твоей точной настройки правила) задача checkstyleMain завершится с ошибкой, указывающей на нарушение.

Этот план обеспечивает постепенное движение от подключения к работающей проверке.

**Сравнение:**

Оба ответа примерно совпадают, последовательность одинаковая.

#### Промпт 2: Проверка кода

**Код для проверки:**

```java
package ru.mentee.power.devtools.progress;

public class ProgressTracker {
public String calculateTotalProgress(Mentee[] mentees) {
if (mentees == null || mentees.length == 0) {
return "Суммарно: пройдено 0 из 0 уроков, осталось 0 уроков";
}

    int totalCompleted = 0;
    int totalTotal = 0;
    int index = 0;

    while (index < mentees.length) {
      totalCompleted += mentees[index].completedLessons();
      totalTotal += mentees[index].totalLessons();
      index++;
    }

    int remaining = totalTotal - totalCompleted;

    return "Суммарно: пройдено " + totalCompleted + " из "
        + totalTotal + " уроков, осталось " + remaining + " уроков";
}

public static void main(String[] args) {
ProgressTracker tracker = new ProgressTracker();
Mentee[] mentees = {
new Mentee("Иван", "Москва", "Backend разработка", 5, 12),
new Mentee("Мария", "Санкт-Петербург", "Fullstack", 8, 12),
new Mentee("Пётр", "Казань", "Java Backend", 12, 12)
};
String progress = tracker.calculateTotalProgress(mentees);
System.out.println(progress);
}
}
```
**Что проверить:**
1. Логические ошибки
2. Соответствие Code Conventions
3. Производительность

**AI-1 (ChatGPT):**

Разберём по пунктам, спокойно и по делу.

---

## 1. Логические ошибки

**Критичных логических ошибок нет** — код корректно считает суммарный прогресс.

Но есть несколько моментов, на которые стоит обратить внимание:

* **Отрицательное `remaining`**
  Если вдруг у какого-то `Mentee` `completedLessons() > totalLessons()`, итоговое `remaining` станет отрицательным.
  Это не ошибка текущей логики, но потенциальная *дыра в доменной модели* — либо нужно гарантировать корректные данные на уровне `Mentee`, либо защищаться здесь.

* **Отсутствие проверки на `null` внутри массива**
  Если `mentees` не `null`, но содержит `null`-элемент — будет `NullPointerException`.

* **Метод возвращает строку, а не данные**
  Это не ошибка, но архитектурный нюанс: метод одновременно считает и форматирует вывод. Это снижает переиспользуемость и тестируемость.

---

## 2. Соответствие Java Code Conventions

Здесь есть несколько заметных нарушений:

### ❌ Форматирование и отступы

* Отсутствуют отступы у тела методов (`calculateTotalProgress`, `main`)
* Блоки `if`, `while` оформлены не по стандарту
* Скобки `{}` не выровнены

Это **прямое нарушение Java Code Conventions** и типичный кандидат для Checkstyle.

---

### ❌ Длина строк

```java
return "Суммарно: пройдено 0 из 0 уроков, осталось 0 уроков";
```

и

```java
return "Суммарно: пройдено " + totalCompleted + " из "
```

— строки достаточно длинные, возможны нарушения `LineLength`, если правило включено.

---

### ⚠️ Имена и структура

* Имена методов и переменных — **корректные**
* `index` — допустимо, но в Java чаще используют `i`
* `totalTotal` — звучит неудачно, ухудшает читаемость (хотя формально допустимо)

---

### ⚠️ `main` внутри бизнес-класса

* Для учебного примера — нормально
* Для production-кода — нарушение SRP (один класс = одна ответственность)

---

## 3. Производительность

### ✅ Всё хорошо для данного масштаба

* Один проход по массиву — **O(n)**
* Конкатенация строк — минимальная, выполняется один раз
* Примитивы (`int`) — без лишних аллокаций

### Микро-замечания (не критично)

* При большом количестве конкатенаций в цикле нужен был бы `StringBuilder`, но **у тебя конкатенация вне цикла**, так что всё ок.
* `while` vs `for` — разницы по производительности нет.

---

## Краткий итог

**Логика:**
✔ Работает корректно
⚠ Возможны edge-cases с некорректными данными

**Code Conventions:**
❌ Нарушены отступы и форматирование
⚠ Неудачное имя `totalTotal`
⚠ Смешение бизнес-логики и `main`

**Производительность:**
✔ Оптимально
✔ Нет лишних операций

Если хочешь, следующим шагом можем:

* разобрать, **какие именно Checkstyle-правила это поймают**
* или пройтись по коду так, как будто его проверяет автоматический code review.


**AI-2 (DeepSeek):**

Отличный код для разбора! Вот что нужно проверить по каждому пункту:

## 1. Логические ошибки

**Проверка 1.1: Корректность вычисления remaining**
- **Что проверить:** Формула `remaining = totalTotal - totalCompleted`
- **Почему:** Если `totalLessons()` может быть меньше `completedLessons()` (теоретически), получится отрицательное значение. Это логическая ошибка данных, но метод должен её обрабатывать.

**Проверка 1.2: Обработка пограничных случаев**
- **Что проверить:** Поведение при `mentees[index].totalLessons() == 0`
- **Почему:** Деление на ноль не происходит, но в выводе будет "0 из 0 уроков" — это корректно, но может быть неинформативно.

**Проверка 1.3: Целочисленное переполнение**
- **Что проверить:** Возможность переполнения `totalCompleted` и `totalTotal` при большом массиве
- **Почему:** Для enterprise-приложения нужно учитывать предельные значения `int`

## 2. Соответствие Code Conventions

**Проверка 2.1: Форматирование и отступы**
- **Что проверить:** Отсутствие пустой строки после открывающей фигурной скобки метода
- **Почему:** По Java Code Conventions (и Google Java Style) такая пустая строка не нужна

**Проверка 2.2: Пробелы вокруг операторов**
- **Что проверить:** Пробелы вокруг `+=`, `<`, `-`, `+` (в конкатенации строк)
- **Почему:** Единообразие улучшает читаемость

**Проверка 2.3: Именование переменных**
- **Что проверить:** Имена `totalTotal` и `totalCompleted`
- **Почему:** `totalTotal` — тавтология. Лучше `totalLessons` или просто `total`

**Проверка 2.4: Комментарии JavaDoc**
- **Что проверить:** Отсутствие документации для публичного метода
- **Почему:** Публичные методы должны иметь JavaDoc, особенно если возвращают специфичный формат строки

**Проверка 2.5: Модификаторы доступа**
- **Что проверить:** Класс не объявлен как `final`, если не предполагается наследование
- **Почему:** Best practice — делать классы `final` по умолчанию, если нет явной необходимости в наследовании

## 3. Производительность

**Проверка 3.1: Использование StringBuilder для конкатенации строк**
- **Что проверить:** Конкатенация строк в цикле или в `return` с помощью `+`
- **Почему:** При конкатенации 4+ строк в одном выражении лучше использовать `StringBuilder` для избежания создания промежуточных объектов

**Проверка 3.2: Выбор цикла**
- **Что проверить:** Использование `while` вместо `for` или enhanced for-loop
- **Почему:** Enhanced for-loop (`for (Mentee mentee : mentees)`) читабельнее и исключает ошибки с индексом

**Проверка 3.3: Повторный вызов методов**
- **Что проверить:** Двойной вызов `mentees[index]` в цикле
- **Почему:** Можно сохранить ссылку в локальную переменную для производительности и читаемости

**Проверка 3.4: Проверка массива на `null` и пустоту**
- **Что проверить:** Проверка `mentees.length == 0` после проверки на `null`
- **Почему:** Это оптимально, но можно рассмотреть `if (mentees == null || mentees.length == 0)` как стандартный подход

**Проверка 3.5: Immutability входных параметров**
- **Что проверить:** Метод не изменяет входной массив, что хорошо
- **Почему:** Отсутствие side effects — важный аспект производительности (предсказуемость) и thread-safety

---

### Критические замечания по приоритету:

1. **Высокий приоритет:** Логическая ошибка с возможным отрицательным `remaining` и отсутствие JavaDoc
2. **Средний приоритет:** Тавтология в именовании, использование `while` вместо enhanced for-loop
3. **Низкий приоритет:** Форматирование, пробелы (хотя это важно для Code Conventions)

Код в целом хорош, но эти проверки помогут довести его до production-качества.

**Сравнение:**

DeepSeek расписал более подробно чем ChatGPT, но ChatGPT привел пример лучше как исправить.

## Сценарий ручной проверки DVT-6

### Запуск приложения
1. Откройте Gradle Tool Window (View → Tool Windows → Gradle)
2. Выполните: devtools → Tasks → application → run
3. Ожидаемый вывод в Run Tool Window:
   Суммарно: пройдено 25 из 36 уроков, осталось 11 уроков

### Запуск тестов
1. Откройте Gradle Tool Window
2. Выполните: devtools → Tasks → verification → test
3. Ожидаемый вывод: BUILD SUCCESSFUL, все тесты зелёные

### Отладка через Debug
1. Установите breakpoint на строке цикла while в ProgressTracker.calculateProgress
2. Запустите Debug: кликните правой кнопкой на main → Debug 'ProgressTracker.main()'
3. Используйте Step Over (F8) для прохождения итераций
4. Проверьте Variables: counter, remainingHours должны изменяться корректно
5. Используйте Evaluate Expression (Alt+F8): вычислите remainingLessons * 2
6. Ожидаемый результат Evaluate: 14 (для completedLessons=5, totalLessons=12)

### Что делать при ошибках
- Если вывод некорректен: проверьте логику цикла через Debug
- Если тесты красные: откройте вывод теста, найдите AssertionError, скорректируйте метод
- Если Debug не останавливается: убедитесь, что breakpoint установлен (красный кружок)

## Кодстайл-гайд проекта devtools

Проект следует правилам Google Java Style Guide с адаптацией.
Автоматическая проверка: ./gradlew checkstyleMain

### 1. Именование методов: camelCase

До:    public void add_student(Student s) { }
После: public void addStudent(Student student) { }

Почему: Java Convention требует camelCase для методов.
Источник: https://google.github.io/styleguide/javaguide.html#s5.3-camel-case

### 2. Пробелы после if/for/while

До:    if(condition) {
После: if (condition) {

Почему: улучшает читаемость, отделяет ключевое слово от выражения.
Источник: Oracle Code Conventions — Whitespace

### 3. Длина строки: максимум 120 символов

До:    public List getStudentsFromSpecificCityWithVeryLongName...
После: public List getStudentsByCity(String city) {

Почему: длинные строки затрудняют чтение в редакторе и при code review.
Источник: https://google.github.io/styleguide/javaguide.html#s4.4-column-limit

### 4. Порядок импортов

До:    import java.util.List; import java.util.ArrayList; import java.io.File;
После: import java.io.File; import java.util.ArrayList; import java.util.List;

Почему: алфавитный порядок упрощает поиск импортов.
Источник: IntelliJ IDEA → Code → Optimize Imports

### 5. Фигурные скобки для if

До:    if (condition) doSomething();
После: if (condition) { doSomething(); }

Почему: скобки обязательны даже для однострочных блоков.
Источник: https://google.github.io/styleguide/javaguide.html#s4.1.1-braces-always-used