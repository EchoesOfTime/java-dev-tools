# DevTools Project
[![Java CI with Checkstyle and Coverage](https://github.com/EchoesOfTime/java-dev-tools/actions/workflows/ci.yml/badge.svg)](https://github.com/EchoesOfTime/java-dev-tools/actions/workflows/ci.yml)

## Технологический стек проекта

### Языки и платформы
- **Java 25 LTS** — основной язык разработки
- **Gradle 8.x** — система сборки (через Gradle Wrapper)

### Инструменты качества кода
- **Checkstyle** — статический анализ стиля кода
    - Конфигурация: `config/checkstyle/checkstyle.xml`
    - Запуск: `./gradlew checkstyleMain`
- **JUnit 5** — фреймворк тестирования
    - Запуск: `./gradlew test`

### CI/CD
- **GitHub Actions** — автоматическая проверка PR
    - Checkstyle на каждый коммит
    - Тесты на каждый коммит
    - Конфигурация: `.github/workflows/`

### Правила кода
- Стиль: Google Java Style Guide (через Checkstyle)
- Коммиты: Conventional Commits (`feat:`, `fix:`, `docs:`)
- Ветки: `feature/DVT-X` для задач, `master` — основная
- Pull Request: обязателен для слияния в master

## Quick Start
Через Gradle Tool Window (IDEA):

1. Открыть View → Tool Windows → Gradle.
2. В дереве задач выбери:
   * `Tasks → application → run`
   * `Tasks → build → build`
   * `Tasks → verification → test`
     (все задачи запускай двойным кликом)
3. Альтернативно используй Ctrl + Ctrl (Run Anything)
```bash
gradle run
gradle build
gradle test
```
IDEA выполнит команду без терминала.

## Packages
`ru.mentee.power` — основной пакет с классами

## Таблица переменных/полей MenteeProgress

- `menteeName` – имя студента
- `sprintNumber` – номер спринта
- `plannedHoursPerWeek` - запланированные часы
- `readyForSprint()` - метод без аргументов, который возвращает логическое значение (true или false).

MenteeProgress - String menteeName, int sprintNumber, int plannedHoursPerWeek

Ссылка на урок
- https://mentee-power.xl.ru/learn/eZTCGC3TuEW8P6jDvNRFZw/theory

## Правило веток: feature/DVT-X
В проекте используется стратегия ветвления, основанная на ветках `feature`.
*   `master` — основная ветка для стабильного кода.
*   `feature/DVT-X` — ветка для разработки задачи с идентификатором DVT-3.


## Git локальный цикл: шаги и команды

1.  Внести изменения в код.
2.  `git add <файлы>` — добавить изменения в индекс.
3.  `git commit -m "сообщение"` — зафиксировать изменения.
4.  `git push` — отправить в удалённый репозиторий.


## Информационный поиск — результаты DVT-11

### Запросы и источники

| № | Запрос                        | Операторы                                                         | Официальный источник                                                                                                   | Альтернатива                                                                                                          | Статус | Дата проверки |
|---|-------------------------------|-------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|--------|---------------|
| 1 | Lombok Gradle Short           | site:search.maven.org "lombok" OR site:mvnrepository.com "lombok" | https://search.maven.org/artifact/org.projectlombok/lombok/1.18.30/jar                                                 | https://mvnrepository.com/artifact/org.projectlombok/lombok/1.18.30                                                   | 200 OK | 29.12.2025    |
| 2 | Java Stream API               | site:docs.oracle.com "stream api" intitle:api java 25             | https://docs.oracle.com/en/database/other-databases/nosql-database/25.3/java-api/oracle/kv/pubsub/package-summary.html | https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.2206/develop-applications/using-repository-api.html | 200 OK | 30.12.2025    |
| 3 | горячие клавиши IntelliJ IDEA | site:www.jetbrains.com/help "keymap" "intellij idea"              | https://www.jetbrains.com/help/idea/mastering-keyboard-shortcuts.html                                                  | https://wp-kama.ru/note/php-storm-hotkeys                                                                             | 200 OK | 30.12.2025    |

### AI-промпты и сравнение ассистентов

#### Промпт 1: План решения

**Задача:** Нужно подключить плагин Checkstyle

**Контекст:** Проект собран на Java 25, Gradle

**Ограничения:** Без использования регулярных выражений на данном этапе, простая проверка наличия @ и точки

**Ожидаемый результат:** план из 3-5 шагов, объяснение "почему именно так", НЕ пиши код — я реализую сам

**Критерии успеха:** Плагин Checkstyle подключен, задачи checkstyleMain, checkstyleTest отображается в verification, Gradle

**AI-1 (ChatGPT):**

Окей, давай аккуратный план без кода, как ты и просил. Ниже — 4 шага, каждый с пояснением почему именно так и как это ведёт к критериям успеха.

Шаг 1. Подключить Checkstyle как Gradle-плагин

Что делаем:
Подключаешь стандартный Gradle-плагин Checkstyle и фиксируешь версию Checkstyle (не полагаться на дефолт).

Почему так:

Gradle сам создаёт задачи checkstyleMain и checkstyleTest, но только если плагин подключён правильно.

Фиксация версии важна для Java 25: так ты избежишь сюрпризов с несовместимостью и различиями правил между версиями.

Это минимальное и «каноничное» подключение — без кастомных тасков и магии.

➡️ После этого Gradle уже знает, что такое Checkstyle, но ещё не знает, что именно проверять.

Шаг 2. Завести отдельный конфигурационный файл Checkstyle

Что делаем:
Создаёшь checkstyle.xml (или аналогичное имя) в стандартном месте проекта и указываешь Gradle, что он должен использовать именно этот файл.

Почему так:

Checkstyle всегда работает от конфигурации, без неё задачи формально есть, но фактически бесполезны.

Отдельный файл даёт прозрачность: правила не размазаны по Gradle, их легко читать и менять.

Это позволит тебе сейчас сделать очень простую проверку (наличие @ и .), а позже — безболезненно усложнить логику.

➡️ На этом этапе Checkstyle уже запускается, но может ничего не находить — и это нормально.

Шаг 3. Добавить простое правило без регулярных выражений

Что делаем:
В конфигурации Checkstyle выбираешь максимально простой механизм проверки текста файлов, который работает на уровне символов, а не regex, и настраиваешь его на проверку наличия @ и точки.

Почему так:

Ты соблюдаешь ограничение «без регулярных выражений».

Проверка символов — самый надёжный старт: меньше ложных срабатываний, легче отлаживать.

Такой подход хорошо ложится в философию Checkstyle: сначала простые синтаксические гарантии, потом — более умные правила.

➡️ Здесь появляется реальная проверка, а не просто подключённый плагин.

Шаг 4. Проверить интеграцию с lifecycle verification

Что делаем:
Запускаешь стандартные Gradle-таски (check / verification) и смотришь, что:

checkstyleMain

checkstyleTest
появляются в группе verification и реально выполняются.

Почему так:

Это главный критерий «плагин подключён правильно», а не просто «Gradle не упал».

Если задачи входят в check, значит Checkstyle стал частью CI-пайплайна автоматически.

Ты сразу видишь, как проект будет вести себя на сборке, а не только локально.

➡️ Это финальная валидация, что всё встроено корректно.

Итог

После этих шагов:

Checkstyle подключён ✔

checkstyleMain и checkstyleTest видны в verification ✔

Проверка простая, без regex, и готова к развитию ✔

Если хочешь, следующим шагом можем обсудить как эволюционно усложнять правило, не ломая текущую конфигурацию.

**AI-2 (DeepSeek):**

Отличная задача! Вот пошаговый план, который учитывает ваш контекст и ограничения.

План из 5 шагов
Шаг 1: Добавить плагин Checkstyle в build.gradle
Действие: В блок plugins добавь строку id 'checkstyle'.
Почему: Плагинный DSL — современный и лаконичный способ подключения. Он автоматически настраивает нужные конфигурации и создает стандартные задачи (checkstyleMain, checkstyleTest), которые интегрируются в группу verification. Это основа для всего последующего.

Шаг 2: (Опционально, но рекомендуется) Настроить версию Checkstyle
Действие: В блок checkstyle добавь конфигурацию toolVersion.
Почему: Последняя версия Checkstyle лучше совместима с новыми синтаксическими конструкциями Java (ваша версия Java 25 — это фактически Java 21 LTS или новее на момент ответа). Фиксация версии обеспечивает воспроизводимость сборки на разных машинах.

Шаг 3: Настроить базовую конфигурацию (конфиг или правило)
Действие: Создай файл config/checkstyle/checkstyle.xml или прямо в build.gradle задай простое правило для проверки формата email.
Почему: Checkstyle требует набора правил для проверки. Так как нужна простая проверка (наличие "@" и точки), это можно сделать через встроенную проверку RegexpSinglelineJava (несмотря на её название, мы будем использовать её БЕЗ регулярных выражений, с простым текстом) или создать кастомную проверку. На данном этапе проще начать с базового XML-конфига, даже если он будет содержать только наши кастомные правила.

Шаг 4: Настроить объект checkstyle в build.gradle
Действие: В блок checkstyle укажи путь к созданному конфигурационному файлу через configFile = file(...).
Почему: Нужно явно указать Gradle, какой файл конфигурации использовать. Если этого не сделать, плагин попытается найти дефолтный (sun_checks.xml), который не содержит наших специфичных правил.

Шаг 5: Запустить задачи и проверить интеграцию
Действие: Выполни ./gradlew tasks --group verification или ./gradlew check.
Почему:

Первая команда покажет, что задачи checkstyleMain и checkstyleTest созданы и находятся в нужной группе verification.

Вторая команда (check) запустит все задачи верификации, включая Checkstyle. Это подтвердит, что плагин не только подключен, но и интегрирован в стандартный жизненный цикл сборки (задача check зависит от checkstyleMain и checkstyleTest).

Ключевые моменты реализации проверки (без кода, как концепция):
Для простой проверки наличия "@" и точки в строке (например, в комментариях) в конфигурационном XML можно использовать модуль RegexpSinglelineJava, но передать в параметр format простую строку "@" (а потом "."). Checkstyle будет интерпретировать это не как регулярное выражение, а как буквальный текст для поиска. Это обходной путь в рамках ограничения "без regex".

Более чистый путь — написать простую кастомную проверку (Custom Check), но это выходит за рамки "простого плана подключения".

Критерии успеха, которые ты увидишь после реализации:

В выводе ./gradlew tasks будут задачи checkstyleMain и checkstyleTest в группе Verification tasks.

Команда ./gradlew checkstyleMain выполнится без ошибок конфигурации.

При наличии в коде строки без "@" или без точки (в зависимости от твоей точной настройки правила) задача checkstyleMain завершится с ошибкой, указывающей на нарушение.

Этот план обеспечивает постепенное движение от подключения к работающей проверке.

**Сравнение:**

Оба ответа примерно совпадают, последовательность одинаковая.

#### Промпт 2: Проверка кода

**Код для проверки:**

```java
package ru.mentee.power.devtools.progress;

public class ProgressTracker {
public String calculateTotalProgress(Mentee[] mentees) {
if (mentees == null || mentees.length == 0) {
return "Суммарно: пройдено 0 из 0 уроков, осталось 0 уроков";
}

    int totalCompleted = 0;
    int totalTotal = 0;
    int index = 0;

    while (index < mentees.length) {
      totalCompleted += mentees[index].completedLessons();
      totalTotal += mentees[index].totalLessons();
      index++;
    }

    int remaining = totalTotal - totalCompleted;

    return "Суммарно: пройдено " + totalCompleted + " из "
        + totalTotal + " уроков, осталось " + remaining + " уроков";
}

public static void main(String[] args) {
ProgressTracker tracker = new ProgressTracker();
Mentee[] mentees = {
new Mentee("Иван", "Москва", "Backend разработка", 5, 12),
new Mentee("Мария", "Санкт-Петербург", "Fullstack", 8, 12),
new Mentee("Пётр", "Казань", "Java Backend", 12, 12)
};
String progress = tracker.calculateTotalProgress(mentees);
System.out.println(progress);
}
}
```
**Что проверить:**
1. Логические ошибки
2. Соответствие Code Conventions
3. Производительность

**AI-1 (ChatGPT):**

Разберём по пунктам, спокойно и по делу.

---

## 1. Логические ошибки

**Критичных логических ошибок нет** — код корректно считает суммарный прогресс.

Но есть несколько моментов, на которые стоит обратить внимание:

* **Отрицательное `remaining`**
  Если вдруг у какого-то `Mentee` `completedLessons() > totalLessons()`, итоговое `remaining` станет отрицательным.
  Это не ошибка текущей логики, но потенциальная *дыра в доменной модели* — либо нужно гарантировать корректные данные на уровне `Mentee`, либо защищаться здесь.

* **Отсутствие проверки на `null` внутри массива**
  Если `mentees` не `null`, но содержит `null`-элемент — будет `NullPointerException`.

* **Метод возвращает строку, а не данные**
  Это не ошибка, но архитектурный нюанс: метод одновременно считает и форматирует вывод. Это снижает переиспользуемость и тестируемость.

---

## 2. Соответствие Java Code Conventions

Здесь есть несколько заметных нарушений:

### ❌ Форматирование и отступы

* Отсутствуют отступы у тела методов (`calculateTotalProgress`, `main`)
* Блоки `if`, `while` оформлены не по стандарту
* Скобки `{}` не выровнены

Это **прямое нарушение Java Code Conventions** и типичный кандидат для Checkstyle.

---

### ❌ Длина строк

```java
return "Суммарно: пройдено 0 из 0 уроков, осталось 0 уроков";
```

и

```java
return "Суммарно: пройдено " + totalCompleted + " из "
```

— строки достаточно длинные, возможны нарушения `LineLength`, если правило включено.

---

### ⚠️ Имена и структура

* Имена методов и переменных — **корректные**
* `index` — допустимо, но в Java чаще используют `i`
* `totalTotal` — звучит неудачно, ухудшает читаемость (хотя формально допустимо)

---

### ⚠️ `main` внутри бизнес-класса

* Для учебного примера — нормально
* Для production-кода — нарушение SRP (один класс = одна ответственность)

---

## 3. Производительность

### ✅ Всё хорошо для данного масштаба

* Один проход по массиву — **O(n)**
* Конкатенация строк — минимальная, выполняется один раз
* Примитивы (`int`) — без лишних аллокаций

### Микро-замечания (не критично)

* При большом количестве конкатенаций в цикле нужен был бы `StringBuilder`, но **у тебя конкатенация вне цикла**, так что всё ок.
* `while` vs `for` — разницы по производительности нет.

---

## Краткий итог

**Логика:**
✔ Работает корректно
⚠ Возможны edge-cases с некорректными данными

**Code Conventions:**
❌ Нарушены отступы и форматирование
⚠ Неудачное имя `totalTotal`
⚠ Смешение бизнес-логики и `main`

**Производительность:**
✔ Оптимально
✔ Нет лишних операций

Если хочешь, следующим шагом можем:

* разобрать, **какие именно Checkstyle-правила это поймают**
* или пройтись по коду так, как будто его проверяет автоматический code review.


**AI-2 (DeepSeek):**

Отличный код для разбора! Вот что нужно проверить по каждому пункту:

## 1. Логические ошибки

**Проверка 1.1: Корректность вычисления remaining**
- **Что проверить:** Формула `remaining = totalTotal - totalCompleted`
- **Почему:** Если `totalLessons()` может быть меньше `completedLessons()` (теоретически), получится отрицательное значение. Это логическая ошибка данных, но метод должен её обрабатывать.

**Проверка 1.2: Обработка пограничных случаев**
- **Что проверить:** Поведение при `mentees[index].totalLessons() == 0`
- **Почему:** Деление на ноль не происходит, но в выводе будет "0 из 0 уроков" — это корректно, но может быть неинформативно.

**Проверка 1.3: Целочисленное переполнение**
- **Что проверить:** Возможность переполнения `totalCompleted` и `totalTotal` при большом массиве
- **Почему:** Для enterprise-приложения нужно учитывать предельные значения `int`

## 2. Соответствие Code Conventions

**Проверка 2.1: Форматирование и отступы**
- **Что проверить:** Отсутствие пустой строки после открывающей фигурной скобки метода
- **Почему:** По Java Code Conventions (и Google Java Style) такая пустая строка не нужна

**Проверка 2.2: Пробелы вокруг операторов**
- **Что проверить:** Пробелы вокруг `+=`, `<`, `-`, `+` (в конкатенации строк)
- **Почему:** Единообразие улучшает читаемость

**Проверка 2.3: Именование переменных**
- **Что проверить:** Имена `totalTotal` и `totalCompleted`
- **Почему:** `totalTotal` — тавтология. Лучше `totalLessons` или просто `total`

**Проверка 2.4: Комментарии JavaDoc**
- **Что проверить:** Отсутствие документации для публичного метода
- **Почему:** Публичные методы должны иметь JavaDoc, особенно если возвращают специфичный формат строки

**Проверка 2.5: Модификаторы доступа**
- **Что проверить:** Класс не объявлен как `final`, если не предполагается наследование
- **Почему:** Best practice — делать классы `final` по умолчанию, если нет явной необходимости в наследовании

## 3. Производительность

**Проверка 3.1: Использование StringBuilder для конкатенации строк**
- **Что проверить:** Конкатенация строк в цикле или в `return` с помощью `+`
- **Почему:** При конкатенации 4+ строк в одном выражении лучше использовать `StringBuilder` для избежания создания промежуточных объектов

**Проверка 3.2: Выбор цикла**
- **Что проверить:** Использование `while` вместо `for` или enhanced for-loop
- **Почему:** Enhanced for-loop (`for (Mentee mentee : mentees)`) читабельнее и исключает ошибки с индексом

**Проверка 3.3: Повторный вызов методов**
- **Что проверить:** Двойной вызов `mentees[index]` в цикле
- **Почему:** Можно сохранить ссылку в локальную переменную для производительности и читаемости

**Проверка 3.4: Проверка массива на `null` и пустоту**
- **Что проверить:** Проверка `mentees.length == 0` после проверки на `null`
- **Почему:** Это оптимально, но можно рассмотреть `if (mentees == null || mentees.length == 0)` как стандартный подход

**Проверка 3.5: Immutability входных параметров**
- **Что проверить:** Метод не изменяет входной массив, что хорошо
- **Почему:** Отсутствие side effects — важный аспект производительности (предсказуемость) и thread-safety

---

### Критические замечания по приоритету:

1. **Высокий приоритет:** Логическая ошибка с возможным отрицательным `remaining` и отсутствие JavaDoc
2. **Средний приоритет:** Тавтология в именовании, использование `while` вместо enhanced for-loop
3. **Низкий приоритет:** Форматирование, пробелы (хотя это важно для Code Conventions)

Код в целом хорош, но эти проверки помогут довести его до production-качества.

**Сравнение:**

DeepSeek расписал более подробно чем ChatGPT, но ChatGPT привел пример лучше как исправить.

## Сценарий ручной проверки DVT-6

### Запуск приложения
1. Откройте Gradle Tool Window (View → Tool Windows → Gradle)
2. Выполните: devtools → Tasks → application → run
3. Ожидаемый вывод в Run Tool Window:
   Суммарно: пройдено 25 из 36 уроков, осталось 11 уроков

### Запуск тестов
1. Откройте Gradle Tool Window
2. Выполните: devtools → Tasks → verification → test
3. Ожидаемый вывод: BUILD SUCCESSFUL, все тесты зелёные

### Отладка через Debug
1. Установите breakpoint на строке цикла while в ProgressTracker.calculateProgress
2. Запустите Debug: кликните правой кнопкой на main → Debug 'ProgressTracker.main()'
3. Используйте Step Over (F8) для прохождения итераций
4. Проверьте Variables: counter, remainingHours должны изменяться корректно
5. Используйте Evaluate Expression (Alt+F8): вычислите remainingLessons * 2
6. Ожидаемый результат Evaluate: 14 (для completedLessons=5, totalLessons=12)

### Что делать при ошибках
- Если вывод некорректен: проверьте логику цикла через Debug
- Если тесты красные: откройте вывод теста, найдите AssertionError, скорректируйте метод
- Если Debug не останавливается: убедитесь, что breakpoint установлен (красный кружок)

## Кодстайл-гайд проекта devtools

Проект следует правилам Google Java Style Guide с адаптацией.
Автоматическая проверка: ./gradlew checkstyleMain

### 1. Именование методов: camelCase

До:    public void add_student(Student s) { }
После: public void addStudent(Student student) { }

Почему: Java Convention требует camelCase для методов.
Источник: https://google.github.io/styleguide/javaguide.html#s5.3-camel-case

### 2. Пробелы после if/for/while

До:    if(condition) {
После: if (condition) {

Почему: улучшает читаемость, отделяет ключевое слово от выражения.
Источник: Oracle Code Conventions — Whitespace

### 3. Длина строки: максимум 120 символов

До:    public List getStudentsFromSpecificCityWithVeryLongName...
После: public List getStudentsByCity(String city) {

Почему: длинные строки затрудняют чтение в редакторе и при code review.
Источник: https://google.github.io/styleguide/javaguide.html#s4.4-column-limit

### 4. Порядок импортов

До:    import java.util.List; import java.util.ArrayList; import java.io.File;
После: import java.io.File; import java.util.ArrayList; import java.util.List;

Почему: алфавитный порядок упрощает поиск импортов.
Источник: IntelliJ IDEA → Code → Optimize Imports

### 5. Фигурные скобки для if

До:    if (condition) doSomething();
После: if (condition) { doSomething(); }

Почему: скобки обязательны даже для однострочных блоков.
Источник: https://google.github.io/styleguide/javaguide.html#s4.1.1-braces-always-used

## Личный глоссарий терминов Dev Tools

### Структура глоссария

Каждый термин содержит:
- **RU / EN** — русское и английское название
- **Определение** — краткое (1-2 предложения) объяснение термина
- **Контекст использования** — где и когда применяется
- **Пример** — конкретное применение в коде/команде/документации
- **Источник** — ссылка на официальную документацию

---

### Категория: Java-экосистема

#### JDK — Java Development Kit

**Определение:** Development environment for building applications using the Java programming language. Includes compiler (javac), archiver (jar), documentation generator (javadoc), and other tools.

**Контекст использования:** JDK необходим для компиляции Java-кода в байт-код и создания исполняемых JAR-файлов. Без JDK невозможно собрать Java-проект.

**Пример:** После установки JDK выполняем `java -version` для проверки версии. В IntelliJ IDEA настраиваем Project SDK: File → Project Structure → Project → SDK → выбираем JDK 25.

**Источник:** https://docs.oracle.com/en/java/javase/21/docs/

---

#### JRE — Java Runtime Environment

**Определение:** JRE — это среда выполнения Java, необходимый компонент для запуска Java-приложений на компьютере пользователя. Содержащая виртуальную машину Java (JVM) и стандартные библиотеки классов (Java API), но не содержащая инструментов разработки, пример таких как компилятор javac.

**Контекст использования:** JRE используется на конечных машинах, где нужно запускать Java-программы, но не требуется их компиляция или разработка.

**Пример:** При запуске JAR-файла `java -jar my-app.jar` без наличия компилятора в JRE.

**Источник:** https://docs.oracle.com/en/java/javase/21/docs/specs/man/java.html

---

#### JVM — Java Virtual Machine

**Определение:** Виртуальная машина Java является основой среды выполнения Java, которая исполняет байт-код Java. Обеспечивает независимость Java-программ от аппаратной платформы и операционной системы.

**Контекст использования:** JVM позволяет запускать приложения, написанные на Java, на любых устройствах и операционных системах.

**Пример:** При запуске JAR-файла `java -jar my-app.jar` в JVM происходит выделение памяти, инициализация подсистем, поиск Main-Class, загрузка классов, проверка байт‑код, компилирует его в машинный код и исполняет метод main().

**Источник:** https://docs.oracle.com/javase/8/embedded/develop-apps-platforms/embedded-jvms.htm

---

#### Gradle Wrapper — Gradle Wrapper

**Определение:** Скрипты (`gradlew`, `gradlew.bat`) и файлы конфигурации, который запускает указанную версию Gradle, при необходимости предварительно загружая её.

**Контекст использования:** Используется для гарантии единообразной версии системы сборки для всех разработчиков и CI/CD-системы.

**Пример:** Запуск командой `./gradlew test`.

**Источник:** https://docs.gradle.org/current/userguide/gradle_wrapper.html

---

#### Build Tool — Инструмент сборки

**Определение:** Программа, которая автоматизирует процесс преобразования исходного кода в готовое к использованию программное обеспечение. Он управляет всем жизненным циклом сборки проекта.

**Контекст использования:** Используется для стандартизации и автоматизации сборки проектов.

**Пример:** В Java проекте на Gradle

**Источник:** https://docs.gradle.org/current/userguide/userguide.html

---

#### Dependency — Зависимость

**Определение:** Внешняя библиотека или модуль, от которого зависит проект.

**Контекст использования:** Указывается в файлах конфигурации сборки и автоматически обрабатывается инструментом сборки.

**Пример:** JUnit добавлен как dependency для написания тестов в devtools.

**Источник:** https://docs.gradle.org/current/userguide/dependency_locking.html

---

#### Artifact — Артефакт

**Определение:** Файл, созданный в процессе сборки, такой как JAR или WAR, который может быть опубликован и использован повторно.

**Контекст использования:** Представляет собой выходные данные сборки и может храниться в репозиториях.

**Пример:** После сборки devtools создаётся JAR-artifact.

**Источник:** https://maven.apache.org/guides/introduction/introduction-to-the-pom.html

---

### Категория: Инструменты разработки

#### IDE - Integrated Development Environment (Интегрированная Среда Разработки)

**Определение:** Комплексное программное обеспечение, которое объединяет в едином интерфейсе все основные инструменты, необходимые для разработки, тестирования и отладки программного обеспечения.

**Контекст использования:** Охватывает весь жизненный цикл разработки программного обеспечения — от первого написания кода до поддержки в продакшене.

**Пример:** IntelliJ IDEA для написания Java-кода

**Источник:** https://www.jetbrains.com/idea/

---

#### SDK - Software Development Kit

**Определение:** Набор инструментов, библиотек, документации и примеров кода, предназначенный для разработки программного обеспечения под конкретную платформу, операционную систему, фреймворк или устройство

**Контекст использования:** SDK используют в любой области создания программного обеспечения - от веб-разработки до интернета вещей.

**Пример:** Android SDK — для разработки приложений для мобильной операционной системы Android. iOS SDK — для создания приложений для устройств Apple, таких как iPhone и iPad. Windows SDK — набор инструментов для разработки приложений под операционную систему Windows. Facebook SDK — инструментарий для разработки приложений, интегрированных с платформой Facebook.

**Источник:** https://docs.oracle.com/en/java/javase/25/docs/api/index.html

---

#### Git — Git

**Определение:** Распределённая система контроля версий (VCS), созданная для управления изменениями в файлах. Она позволяет фиксировать историю правок, создавать параллельные ветки разработки и объединять изменения от разных участников.

**Контекст использования:** Командная разработка программного обеспечения для координации работы над кодом. Также используется для версионирования конфигураций, документации и любых текстовых файлов в проектах.

**Пример:** Разработчик создаёт новую ветку для добавления функции, коммитит изменения и отправляет их в общий репозиторий. Коллеги проверяют код через pull request и после одобрения сливают изменения в основную ветку проекта.

**Источник:** https://git-scm.com/book/en/v2

---

#### Repository — Репозиторий

**Определение:** Репозиторий — это хранилище данных, содержащее все файлы проекта вместе с историей их изменений и служебной информацией. В системах контроля версий, таких как Git, репозиторий включает в себя код, коммиты, ветки и метаданные.

**Контекст использования:** Репозиторий используется для хранения и управления версиями любого проекта, будь то программный код, документация или конфигурационные файлы. Он является центральным местом для командной работы, позволяя отслеживать изменения и координировать действия разработчиков.

**Пример:** При начале работы с Git разработчик создаёт локальный репозиторий командой git init или клонирует удалённый с GitHub через git clone. Вся дальнейшая работа с коммитами и ветками происходит внутри этого репозитория, который затем синхронизируется с удалённым сервером.

**Источник:** https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository

---

#### Commit — Коммит

**Определение:** Коммит — это фиксация изменений, создающая постоянный снимок (снапшот) текущего состояния файлов в репозитории. Каждый коммит содержит уникальный идентификатор (хеш), автора, дату и сообщение, описывающее внесённые изменения.

**Контекст использования:** Коммиты используются для сохранения логически завершённых этапов работы, таких как добавление новой функции или исправление ошибки. Они формируют историю проекта, что позволяет отслеживать прогресс, возвращаться к предыдущим версиям и совместно работать над кодом.

**Пример:** После внесения изменений в файлы разработчик использует команду `git commit -m "Наименование"`. Эта команда создаёт новый коммит с заданным сообщением, фиксируя текущее состояние индекса как точку в истории проекта.

**Источник:** https://git-scm.com/docs/git-commit

---

#### Branch — Ветка

**Определение:** Ветка в Git — это легковесный подвижный указатель на определённый коммит в истории проекта. По сути, это независимая линия разработки, которая позволяет вам отклоняться от основной линии (например, main) и работать изолированно, не затрагивая работу других.

**Контекст использования:** Ветки используются для изолированной разработки новых функций, экспериментов или исправления ошибок, не мешая стабильной основной версии кода. Они являются основным механизмом для командной работы, позволяя нескольким разработчикам параллельно вносить изменения, которые затем можно объединить.

**Пример:** Чтобы начать работу над новой функцией, разработчик создаёт ветку командой `git branch new-feature` и переключается на неё с помощью `git checkout new-feature`. Все последующие коммиты будут сохраняться в этой ветке, пока разработчик не решит объединить её с основной.

**Источник:** https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell

---

#### Branch — Ветка

**Определение:** Ветка в Git — это легковесный подвижный указатель на определённый коммит в истории проекта. По сути, это независимая линия разработки, которая позволяет вам отклоняться от основной линии (например, main) и работать изолированно, не затрагивая работу других.

**Контекст использования:** Ветки используются для изолированной разработки новых функций, экспериментов или исправления ошибок, не мешая стабильной основной версии кода. Они являются основным механизмом для командной работы, позволяя нескольким разработчикам параллельно вносить изменения, которые затем можно объединить.

**Пример:** Чтобы начать работу над новой функцией, разработчик создаёт ветку командой `git branch new-feature` и переключается на неё с помощью `git checkout new-feature`. Все последующие коммиты будут сохраняться в этой ветке, пока разработчик не решит объединить её с основной.

**Источник:** https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell

---

#### Pull Request - Pull Request (Пул-реквест)

**Определение:** Pull Request (или Merge Request) — это механизм в системах контроля версий, который позволяет разработчику предложить изменения, сделанные в одной ветке, для слияния с другой веткой (например, с основной). Это не только технический запрос на слияние кода, но и центральная точка для обсуждения предлагаемых изменений до их интеграции.

**Контекст использования:** Pull Request широко используется в командной разработке для проверки кода (code review), обсуждения реализации новых функций, автоматического запуска тестов и непрерывной интеграции (CI) перед слиянием изменений в стабильную ветку. Он является ключевой практикой в популярных методологиях разработки, таких как GitHub Flow или GitLab Flow, обеспечивая качество кода и совместную работу.

**Пример:** Разработчик, завершив работу над новой функцией в ветке `feature/new-payment`, создаёт Pull Request в веб-интерфейсе GitHub, чтобы предложить слить эти изменения в ветку main. Другие участники проекта просматривают код, оставляют комментарии, и после прохождения всех проверок и утверждения изменения объединяются (мержатся).

**Источник:** https://docs.github.com/en/pull-requests

---

#### Checkstyle - Checkstyle

**Определение:** Checkstyle — это статический анализатор кода для языков программирования, в первую очередь Java. Он проверяет исходный код на соответствие заданным правилам оформления и стандартам кодирования, таким как соглашения по именованию, использование пробелов, размещение скобок и длина строк.

**Контекст использования:** Инструмент используется в процессе разработки, часто интегрируясь в системы сборки (Maven, Gradle) или среды разработки (IDE), чтобы автоматически проверять код во время его написания или сборки. Это позволяет командам поддерживать единый стиль кода в проекте, улучшать его читаемость и предотвращать появление распространённых дефектов, связанных с оформлением.

**Пример:** В проекте на Maven разработчик может добавить плагин `maven-checkstyle-plugin` в файл `pom.xml` и указать конфигурационный файл, например, `google_checks.xml`. После этого при запуске команды `mvn verify` Checkstyle автоматически просканирует исходные файлы и создаст отчёт о нарушениях, что поможет команде привести код к единому стандарту.

**Источник:** https://checkstyle.sourceforge.io/

---

#### Debug - Отладка

**Определение:** Процесс выявления, локализации и исправления ошибок (багов) в программном коде. Она включает в себя анализ неожиданного поведения программы для поиска его причины в исходном коде, данных или окружении.

**Контекст использования:** Отладка используется разработчиками на всех этапах создания ПО: при написании нового функционала, когда программа работает некорректно (выдаёт ошибку, зависает, возвращает неверные данные), или во время тестирования для проверки логики работы. Это ключевой навык для решения проблем в коде.

**Пример:** Программист, заметив, что приложение аварийно завершается при выполнении определённого действия, использует отладчик в среде разработки (IDE), чтобы пошагово исполнить код, отследить значения переменных и найти строку, вызывающую ошибку (например, обращение к несуществующему элементу массива).

**Источник:** https://www.jetbrains.com/help/idea/debugging-code.html

---

#### Breakpoint - Точка останова

**Определение:** Breakpoint - это специальные маркеры, которые приостанавливают выполнение программы в определённой точке. Это позволяет изучить состояние и поведение программы.

**Контекст использования:** Точки останова активно используются в процессе отладки (debugging) для анализа логики выполнения и поиска причин ошибок. Их устанавливают в средах разработки (IDE) на строках кода, где необходимо проверить корректность данных или последовательность выполнения операций.

**Пример:** Кликаем слева от номера строки в IntelliJ IDEA — появляется красная точка (breakpoint). Чтобы установить временную точку останова, нажмите `Ctr` `lAlt` `Shift` `F8`

**Источник:** https://www.jetbrains.com/help/idea/using-breakpoints.html#set-breakpoints

---

### Категория: Процессы и практики

#### Code Review — Code Review (Код ревью)

**Определение:** Cистематическая проверка исходного кода одним или несколькими разработчиками, не являющимися его авторами. Основная цель — выявить потенциальные ошибки, улучшить качество кода, обеспечить соответствие стандартам проекта и распространить знания о кодовой базе внутри команды.

**Контекст использования:** Ревью кода проводится перед слиянием изменений в основную ветку разработки, обычно как часть процесса работы с pull/merge request. Это стандартная практика в современных методологиях разработки (Agile, DevOps) для поддержания качества кода, повышения его безопасности и обмена опытом между членами команды.

**Пример:** Разработчик создаёт pull request с новой функцией. Другой член команды изучает предложенный код в интерфейсе GitHub, оставляет комментарии к конкретным строкам: "Здесь лучше использовать константу" или "Рассмотри возможность обработки этого исключения". Автор вносит правки на основе обратной связи, после чего изменения утверждаются и сливаются.

**Источник:** https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/about-pull-request-reviews

---

#### CI/CD — Continuous Integration / Continuous Delivery

**Определение:** Continuous Integration (Непрерывная интеграция, CI) — это практика автоматической сборки и тестирования каждого изменения кода, поступающего в репозиторий. Continuous Delivery/Deployment (Непрерывная доставка/развертывание, CD) — это автоматизация дальнейших этапов: развертывания протестированных изменений в тестовую, промежуточную и, в случае Continuous Deployment, в рабочую среду.

**Контекст использования:** CI/CD применяется в современных командных процессах разработки для минимизации ручного труда, ускорения выпуска обновлений и повышения их надежности. Эта практика является основой подходов DevOps и используется практически во всех agile-командах, разрабатывающих веб-сервисы, мобильные приложения и облачные решения.

**Пример:** Разработчик делает коммит в ветку `main`. CI/CD-пайплайн (например, в GitHab CI) автоматически запускается: 1) CI-этап: собирает приложение, запускает модульные тесты; 2) CD-этап: если тесты пройдены, автоматически разворачивает новую версию на тестовый сервер для QA, а после ручного подтверждения — на продакшен.

**Источник:** https://docs.github.com/en/actions/tutorials/build-and-test-code/java-with-gradle

---

#### Runbook — Руководство по эксплуатации

**Определение:** Cтруктурированный набор документации и инструкций, описывающих шаги для выполнения конкретной рутинной IT-задачи, реагирования на инцидент или восстановления сервиса. Обычно он содержит чёткие команды, скрипты, условия и критерии успеха для каждого шага.

**Контекст использования:** Runbook используются командами DevOps, SRE (Site Reliability Engineering) и системными администраторами для стандартизации рутинных операций (например, развертывания приложения), а также для быстрого и корректного решения инцидентов (например, падения базы данных). Это ключевой элемент для обеспечения надежности систем и снижения операционных рисков.

**Пример:** При возникновении инцидента "Высокая загрузка CPU на веб-сервере" инженер открывает соответствующий Runbook. В нём пошагово описаны действия: 1) Проверить логи сервера; 2) Выполнить команду top для анализа процессов; 3) При обнаружении проблемного процесса — выполнить скрипт для его перезапуска; 4) Убедиться в восстановлении метрик.

**Источник:** https://learn.microsoft.com/ru-ru/system-center/orchestrator/automate-runbooks?view=sc-orch-2025&tabs=Create

---
## Вопросы по сложным терминам

### Вопрос 1: Не до конца понимаю разницу между JDK, JRE, JVM

**Задача:** Чётко понять разницу между JDK, JRE и JVM, а также их иерархическую взаимосвязь в экосистеме Java.

**Контекст:** Изучил определения в Oracle Docs, но практическое применение не ясно. У меня установлен JDK 25, в build.gradle нет упоминания JRE.

**Ограничения:** Попытки запомнить определения отдельно не дают полной картины. Нужно увидеть их как части одной системы и понять практическую роль каждого компонента.

**Ожидаемый результат:** Умение объяснить, что такое JDK, JRE и JVM, простой аналогией, и точно знать, какой компонент нужен для разработки, а какой — только для запуска программ.

**Критерии успеха:** Чёткое понимание роли каждого компонента в практическом ключе.

JDK — это полный рабочий комплект для программиста, который создаёт Java-приложения. В нём есть все инструменты для написания, компиляции и отладки кода.

JRE — это минимальный комплект для конечного пользователя, которому нужно только запустить готовое приложение. Он содержит всё необходимое для исполнения программ, но не для их создания.

JVM — это исполнительное ядро, которое входит в состав как JRE, так и JDK. Его единственная задача — читать и выполнять скомпилированный байт-код программы, обеспечивая её работу на конкретном устройстве.

---

### Вопрос 2: CI/CD — Continuous Integration / Continuous Delivery

**Задача:** Понять разницу между Continuous Integration и Continuous Delivery/Deployment, их взаимосвязь и практическую ценность. Нужно уточнить, чем CD как "доставка" отличается от CD как "развертывания".

**Контекст:** Термин постоянно встречается в вакансиях DevOps, статьях про современные методологии разработки (Agile, DevOps), описаниях инструментов (Jenkins, GitLab CI, GitHub Actions) и при обсуждении практик автоматизации в IT-командах.

**Ограничения:** Определения из статей иногда противоречивы, особенно по поводу "Delivery" и "Deployment". Сложно представить полный рабочий цикл CI/CD-пайплайна от коммита до продакшена.

**Ожидаемый результат:** Чёткое понимание, что CI — это автоматизация сборки и тестирования, а CD — это автоматизация процессов после тестов. Умение объяснить, что Continuous Delivery требует ручного подтверждения для развертывания в прод, а Continuous Deployment — нет.

**Критерии успеха:** Смогу на примере реального проекта описать, какие этапы автоматизации относятся к CI (непрерывной интеграции), а какие — к CD (непрерывной доставке или развертыванию). Также смогу доступно объяснить разницу между этими понятиями коллеге.
